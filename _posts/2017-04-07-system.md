---
layout: post
title:  "note of Computer System"
image: ''
date:   2017-04-07 12:54:43
tags:
- coding for fun
description: ''
categories:
- Learn 
---

#  进程的状态
- 三种基本状态：
1.就绪态：当进程已分配到除CPU以外的所有必要的资源，给他一个CPU立马可以起飞，就成为就绪态。
2.执行态：在处理机上运行。
3.阻塞状态：正在执行的进程，等待某个事件发生无法执行时，变放弃处理。例如：等待io，申请缓冲区失败，等待信号。
- 进程转换：
1.就绪->执行：获得了处理器
2.执行->就绪：时间片用完，进程调度
3.执行->阻塞：发生某种事件无法继续执行
4.阻塞->就绪：等待的事件已经完成
#  进程和线程的区别联系
- 进程：
是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机资源的基本单位，每一个进程都有自己的地址空间，进程空间。进程空间的大小只与处理机的位数有关，一个长16位的处理器的进程空间的大小为216，而32位的为232。
- 线程：
在网络或多用户的环境下，一个服务器通常需要接受大量且不确定数量的用户请求，为每一个请求都创建进程行不通，系统开销和效率都不实际。线程是进程的一部分，一个没有线程的进程可以被看做是单线程。
- 联系与区别：
线程的改变只代表CPU执行过程的改变，而没有发生进程所拥有的资源变换。进程拥有一个完整的虚拟地址空间，不依赖线程而独立存在；而线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给进程的所有资源。

# 进程间通信
- 匿名管道 父子进程之间
- 命名管道
- 信号
- 共享内存
- 套接字 socket

# 进程同步
- 互斥锁
- 条件变量
- 信号量

# 用户态和核心态
- 用户态：只能受限的访问内存
- 核心态：cpu可以访问内存所有数据，包括外围设备，也可以将自己从一个程序切换到另一个程序。
- 切换过程：用户程序在用户态运行，但是有时候需要做一些内核态做的事情，程序就需要向操作系统请求执行这些操作，这时候就需要用户态切换到内核态。系统调用。
1.用户态将数值放在寄存器中，或者创建一个堆栈，表明需要的服务。
2.用户态执行陷阱命令。
3.CPU切换到内核态，并跳转到位于内存指定位置的命令，用户态程序无法访问。
4.执行程序请求的服务。
5.系统调用完成，重置cpu为用户态并返回系统调用的结果。

# 内核栈和用户栈
内核在创建进程的时候，创建两个堆栈，分别用于用户态运行和核心态运行。

# 内存池，进程池，线程池
- 内存池：用new，malloc分配内存时，申请的内存块大小不定，会造成大量的内存碎片降低性能。内存池就是在使用内存前，申请分配一定数量，大小相等的内存块留做备用，使得内存分配效率得到提升。
- 进程池：服务器预先创建一组子进程，子进程运行着相同的代码，相同的属性，当有新的任务来临时，主进程通过某种方式选择进程池中一个进程为其服务。
- 线程池：需要大量线程来完成任务，且实现任务的时间比较短，适合用线程池，节约创建线程的时间。

# 死锁的概念和原因
- 死锁：进程集合中的每一个进程都在等待一个进程才能继续执行，无外力无法推进，这种就叫死锁。
- 互斥条件：分配到的资源不共享
- 请求和保持条件：请求不到资源，但仍保持自己的资源不放。
- 不可剥夺条件：进程在使用完资源前不可以被剥夺资源
- 环路等待：必然存在一个环路。
- 解决方法：
1.预防死锁：破坏条件
2.避免死锁：银行家
3.检测死锁：发生发生死锁，立马干预
4.解除死锁：配合检测使用。

# 进程调度算法
- 先来先服务算法
- 短作业优先调度算法
- 优先权调度算法
- 时间片轮转法

# 内存管理的方式
- 单一连续的存储管理方式：
内存被分为两个区域：系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。其特点是简单，使用与单用户单任务的操作系统。不足在于程序全部装入内存，造成内存浪费。
- 分区式存储管理：
为了支持多道程序系统和分时系统，支持多个程序并发执行。将内存分为一些大小相等或者不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或者几个分区。缺点：内碎片（块内碎片）外碎片（块间碎片），限制了并发执行的程序数目。
- 页式存储管理：
```
原理：将程序的逻辑地址空间划分为固定大小的页，而无力内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框中，这些页框不用连续，实现了离散分配。
缺点：要求程序全部装入内存，没有足够内存就无法执行。
```
- 段式存储管理：
原理：在段式存储管理中，将程序的地址空间划分为若干个段，为每一个段分配一个连续的分区，进程的不同段可以不连续的存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存。例如代码段，数据段，共享段。
缺点：需要全部装入内存。
- 段页式存储：
原理：先分段，再分页。

# 内存连续分配
- 单一连续分配
- 固定分区分配
- 动态分区分配
- 首次适应算法
- 循环首次适应算法
- 最佳适应算法
- 最差适应算法

# 分段分页各自优缺点
- 分页是便于系统管理，分段是便于用户需求
- 分页地址是以为的，程序员只需要一个记忆符，而分段是二维的，需要段名和段内地址

# 页面置换算法
缺页中断后调用：
- 最佳置换法：替换不会用到的页面，没有就替换最久没有使用的，理想情况。
- 先进先出置换：先进入页表的先被替换
- 最近最久未使用算法：最近一段时间内最久没有被使用的页面进行淘汰。

# 操作系统的四个特性
并发性、共享性、虚拟性、异步性
