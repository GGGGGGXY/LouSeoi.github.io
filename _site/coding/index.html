<!DOCTYPE html>
<html lang="pt-br">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Half month in Leetcode</title>

    <meta name="description" content="">

    <!-- Google Authorship Markup -->
    <link rel="author" href="https://plus.google.com/NONE?rel=author">

    <!-- Social Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@RiziaGXY">
    <meta name="twitter:title" content="Half month in Leetcode">
    <meta name="twitter:description" content="">

    
    <meta property="twitter:image:src" content="http://localhost:4000">
    

    <!-- Social Facebook/Open Graph -->
    <meta property="og:url" content="http://localhost:4000/coding/">
    <meta property="og:title" content="Half month in Leetcode">
    
    <meta property="og:image" content="http://localhost:4000">
    
    <meta property="og:description" content="">
    <meta property="og:site_name" content="GaoXinyu - Jungler">

    <!-- Social Google+/Schema.org  -->
    <meta itemprop="name" content="Half month in Leetcode"/>
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://localhost:4000/assets/img/blog-image.png"/>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/assets/img/icons/favicon.ico" type="image/x-icon" />

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="/assets/img/icons/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/img/icons/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/icons/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/icons/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/icons/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/img/icons/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/img/icons/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/icons/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/img/icons/apple-touch-icon-152x152.png" />

    <!-- Windows 8 Tile Icons -->
    <meta name="application-name" content="Rizia Blog">
    <meta name="msapplication-TileColor" content="#5d4d7a">
    <meta name="msapplication-square70x70logo" content="smalltile.png" />
    <meta name="msapplication-square150x150logo" content="mediumtile.png" />
    <meta name="msapplication-wide310x150logo" content="widetile.png" />
    <meta name="msapplication-square310x310logo" content="largetile.png" />

    <!-- Android Lolipop Theme Color -->
    <meta name="theme-color" content="#5d4d7a">

    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="http://localhost:4000/coding/">
    <link rel="alternate" type="application/rss+xml" title="GaoXinyu - Jungler" href="http://localhost:4000/feed.xml" />
</head>

    <body>
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" display="none" version="1.1"><defs><symbol id="icon-menu" viewBox="0 0 1024 1024"><path class="path1" d="M128 213.333h768q17.667 0 30.167 12.5t12.5 30.167-12.5 30.167-30.167 12.5h-768q-17.667 0-30.167-12.5t-12.5-30.167 12.5-30.167 30.167-12.5zM128 725.333h768q17.667 0 30.167 12.5t12.5 30.167-12.5 30.167-30.167 12.5h-768q-17.667 0-30.167-12.5t-12.5-30.167 12.5-30.167 30.167-12.5zM128 469.333h768q17.667 0 30.167 12.5t12.5 30.167-12.5 30.167-30.167 12.5h-768q-17.667 0-30.167-12.5t-12.5-30.167 12.5-30.167 30.167-12.5z"/></symbol><symbol id="icon-search" viewBox="0 0 951 1024"><path class="path1" d="M658.286 475.429q0-105.714-75.143-180.857t-180.857-75.143-180.857 75.143-75.143 180.857 75.143 180.857 180.857 75.143 180.857-75.143 75.143-180.857zM950.857 950.857q0 29.714-21.714 51.429t-51.429 21.714q-30.857 0-51.429-21.714l-196-195.429q-102.286 70.857-228 70.857-81.714 0-156.286-31.714t-128.571-85.714-85.714-128.571-31.714-156.286 31.714-156.286 85.714-128.571 128.571-85.714 156.286-31.714 156.286 31.714 128.571 85.714 85.714 128.571 31.714 156.286q0 125.714-70.857 228l196 196q21.143 21.143 21.143 51.429z"/></symbol><symbol id="icon-email" viewBox="0 0 1024 1024"><path class="path1" d="M950.857 859.429v-438.857q-18.286 20.571-39.429 37.714-153.143 117.714-243.429 193.143-29.143 24.571-47.429 38.286t-49.429 27.714-58.571 14h-1.143q-27.429 0-58.571-14t-49.429-27.714-47.429-38.286q-90.286-75.429-243.429-193.143-21.143-17.143-39.429-37.714v438.857q0 7.429 5.429 12.857t12.857 5.429h841.143q7.429 0 12.857-5.429t5.429-12.857zM950.857 258.857v-14t-0.286-7.429-1.714-7.143-3.143-5.143-5.143-4.286-8-1.429h-841.143q-7.429 0-12.857 5.429t-5.429 12.857q0 96 84 162.286 110.286 86.857 229.143 181.143 3.429 2.857 20 16.857t26.286 21.429 25.429 18 28.857 15.714 24.571 5.143h1.143q11.429 0 24.571-5.143t28.857-15.714 25.429-18 26.286-21.429 20-16.857q118.857-94.286 229.143-181.143 30.857-24.571 57.429-66t26.571-75.143zM1024 237.714v621.714q0 37.714-26.857 64.571t-64.571 26.857h-841.143q-37.714 0-64.571-26.857t-26.857-64.571v-621.714q0-37.714 26.857-64.571t64.571-26.857h841.143q37.714 0 64.571 26.857t26.857 64.571z"/></symbol><symbol id="icon-close" viewBox="0 0 805 1024"><path class="path1" d="M741.714 755.429q0 22.857-16 38.857l-77.714 77.714q-16 16-38.857 16t-38.857-16l-168-168-168 168q-16 16-38.857 16t-38.857-16l-77.714-77.714q-16-16-16-38.857t16-38.857l168-168-168-168q-16-16-16-38.857t16-38.857l77.714-77.714q16-16 38.857-16t38.857 16l168 168 168-168q16-16 38.857-16t38.857 16l77.714 77.714q16 16 16 38.857t-16 38.857l-168 168 168 168q16 16 16 38.857z"/></symbol><symbol id="icon-twitter" viewBox="0 0 951 1024"><path class="path1" d="M925.714 233.143q-38.286 56-92.571 95.429 0.571 8 0.571 24 0 74.286-21.714 148.286t-66 142-105.429 120.286-147.429 83.429-184.571 31.143q-154.857 0-283.429-82.857 20 2.286 44.571 2.286 128.571 0 229.143-78.857-60-1.143-107.429-36.857t-65.143-91.143q18.857 2.857 34.857 2.857 24.571 0 48.571-6.286-64-13.143-106-63.714t-42-117.429v-2.286q38.857 21.714 83.429 23.429-37.714-25.143-60-65.714t-22.286-88q0-50.286 25.143-93.143 69.143 85.143 168.286 136.286t212.286 56.857q-4.571-21.714-4.571-42.286 0-76.571 54-130.571t130.571-54q80 0 134.857 58.286 62.286-12 117.143-44.571-21.143 65.714-81.143 101.714 53.143-5.714 106.286-28.571z"/></symbol><symbol id="icon-facebook" viewBox="0 0 585 1024"><path class="path1" d="M548 6.857v150.857h-89.714q-49.143 0-66.286 20.571t-17.143 61.714v108h167.429l-22.286 169.143h-145.143v433.714h-174.857v-433.714h-145.714v-169.143h145.714v-124.571q0-106.286 59.429-164.857t158.286-58.571q84 0 130.286 6.857z"/></symbol><symbol id="icon-rss" viewBox="0 0 805 1024"><path class="path1" d="M219.429 768q0 45.714-32 77.714t-77.714 32-77.714-32-32-77.714 32-77.714 77.714-32 77.714 32 32 77.714zM512 838.286q1.143 16-9.714 27.429-10.286 12-26.857 12h-77.143q-14.286 0-24.571-9.429t-11.429-23.714q-12.571-130.857-105.429-223.714t-223.714-105.429q-14.286-1.143-23.714-11.429t-9.429-24.571v-77.143q0-16.571 12-26.857 9.714-9.714 24.571-9.714h2.857q91.429 7.429 174.857 46t148 103.714q65.143 64.571 103.714 148t46 174.857zM804.571 839.429q1.143 15.429-10.286 26.857-10.286 11.429-26.286 11.429h-81.714q-14.857 0-25.429-10t-11.143-24.286q-6.857-122.857-57.714-233.429t-132.286-192-192-132.286-233.429-58.286q-14.286-0.571-24.286-11.143t-10-24.857v-81.714q0-16 11.429-26.286 10.286-10.286 25.143-10.286h1.714q149.714 7.429 286.571 68.571t243.143 168q106.857 106.286 168 243.143t68.571 286.571z"/></symbol><symbol id="icon-google-plus" viewBox="0 0 951 1024"><path class="path1" d="M420 454.857q0 20.571 18.286 40.286t44.286 38.857 51.714 42 44 59.429 18.286 81.143q0 51.429-27.429 98.857-41.143 69.714-120.571 102.571t-170.286 32.857q-75.429 0-140.857-23.714t-98-78.571q-21.143-34.286-21.143-74.857 0-46.286 25.429-85.714t67.714-65.714q74.857-46.857 230.857-57.143-18.286-24-27.143-42.286t-8.857-41.714q0-20.571 12-48.571-26.286 2.286-38.857 2.286-84.571 0-142.571-55.143t-58-139.714q0-46.857 20.571-90.857t56.571-74.857q44-37.714 104.286-56t124.286-18.286h238.857l-78.857 50.286h-74.857q42.286 36 64 76t21.714 91.429q0 41.143-14 74t-33.714 53.143-39.714 37.143-34 35.143-14 37.714zM336.571 400q21.714 0 44.571-9.429t37.714-24.857q30.286-32.571 30.286-90.857 0-33.143-9.714-71.429t-27.714-74-48.286-59.143-66.857-23.429q-24 0-47.143 11.143t-37.429 30q-26.857 33.714-26.857 91.429 0 26.286 5.714 55.714t18 58.857 29.714 52.857 42.857 38.286 55.143 14.857zM337.714 898.857q33.143 0 63.714-7.429t56.571-22.286 41.714-41.714 15.714-62.286q0-14.286-4-28t-8.286-24-15.429-23.714-16.857-20-22-19.714-20.857-16.571-23.714-17.143-20.857-14.857q-9.143-1.143-27.429-1.143-30.286 0-60 4t-61.429 14.286-55.429 26.286-39.143 42.571-15.429 60.286q0 40 20 70.571t52.286 47.429 68 25.143 72.857 8.286zM800.571 398.286h121.714v61.714h-121.714v125.143h-60v-125.143h-121.143v-61.714h121.143v-124h60v124z"/></symbol><symbol id="icon-github-alt" viewBox="0 0 951 1024"><path class="path1" d="M365.714 694.857q0 22.857-7.143 46.857t-24.571 43.429-41.429 19.429-41.429-19.429-24.571-43.429-7.143-46.857 7.143-46.857 24.571-43.429 41.429-19.429 41.429 19.429 24.571 43.429 7.143 46.857zM731.429 694.857q0 22.857-7.143 46.857t-24.571 43.429-41.429 19.429-41.429-19.429-24.571-43.429-7.143-46.857 7.143-46.857 24.571-43.429 41.429-19.429 41.429 19.429 24.571 43.429 7.143 46.857zM822.857 694.857q0-68.571-39.429-116.571t-106.857-48q-23.429 0-111.429 12-40.571 6.286-89.714 6.286t-89.714-6.286q-86.857-12-111.429-12-67.429 0-106.857 48t-39.429 116.571q0 50.286 18.286 87.714t46.286 58.857 69.714 34.286 80 16.857 85.143 4h96q46.857 0 85.143-4t80-16.857 69.714-34.286 46.286-58.857 18.286-87.714zM950.857 594.286q0 118.286-34.857 189.143-21.714 44-60.286 76t-80.571 49.143-97.143 27.143-98 12.571-95.429 2.571q-44.571 0-81.143-1.714t-84.286-7.143-87.143-17.143-78.286-29.429-69.143-46.286-49.143-65.714q-35.429-70.286-35.429-189.143 0-135.429 77.714-226.286-15.429-46.857-15.429-97.143 0-66.286 29.143-124.571 61.714 0 108.571 22.571t108 70.571q84-20 176.571-20 84.571 0 160 18.286 60-46.857 106.857-69.143t108-22.286q29.143 58.286 29.143 124.571 0 49.714-15.429 96 77.714 91.429 77.714 227.429z"/></symbol><symbol id="icon-right-arrow"><path d="M21.205,5.007c-0.429-0.444-1.143-0.444-1.587,0c-0.429,0.429-0.429,1.143,0,1.571l8.047,8.047H1.111  C0.492,14.626,0,15.118,0,15.737c0,0.619,0.492,1.127,1.111,1.127h26.554l-8.047,8.032c-0.429,0.444-0.429,1.159,0,1.587  c0.444,0.444,1.159,0.444,1.587,0l9.952-9.952c0.444-0.429,0.444-1.143,0-1.571L21.205,5.007z" fill="#489472"/></symbol></defs></svg>

        <header class="header-post">
   	<p>Rizia</p>
    <div class="search-wrapper">

    <div class="search-form">
        <input arial-label="Search for a post" type="text" class="search-field" placeholder="Search...">
        <svg class="icon-remove-sign"><use xlink:href="#icon-close"></use></svg>

        <ul class="search-results search-list"></ul>
    </div>

</div>

<!-- Menu Open -> Fade effect -->
<div id="fade" class="overlay"></div>
<a id="slide" class="slideButton fade">
    <svg id="open" class="icon-menu"><use xlink:href="#icon-menu"></use></svg>
    <svg id="close" class="icon-menu"><use xlink:href="#icon-close"></use></svg>
</a>

<aside id="sidebar">
  <div id="topmenu">
    
    <ul>
      <li><span>1</span></li>
      <li><span> /coding/</span></li>
      <li><span> Rizia </span></li>
      <li><span>* Menu</span></li>
    </ul>

    <ul>
      <li><span>utf-8</span></li>
      <li><span>web</span></li>
      <li><span>.html</span></li>
    </ul>
  </div>

  <nav id="navigation" role="navigation">
    <ul>
      
      
      
        <li>
          <span class="counter-menu">1</span>
          <svg viewBox="0 0 50 50" class="icon-arrow-menu"><use xlink:href="#icon-right-arrow"></use></svg>
          <a href="http://localhost:4000/"> home</a>
        </li>
      

         
      
      
        <li>
          <span class="counter-menu">2</span>
          <svg viewBox="0 0 50 50" class="icon-arrow-menu"><use xlink:href="#icon-right-arrow"></use></svg>
          <a href="http://localhost:4000/posts"> my posts</a>
        </li>
      

         
      
      
        <li>
          <span class="counter-menu">3</span>
          <svg viewBox="0 0 50 50" class="icon-arrow-menu"><use xlink:href="#icon-right-arrow"></use></svg>
          <a href="http://localhost:4000/series"> series</a>
        </li>
      

         
      
      
        <li>
          <span class="counter-menu">4</span>
          <svg viewBox="0 0 50 50" class="icon-arrow-menu"><use xlink:href="#icon-right-arrow"></use></svg>
          <a href="http://localhost:4000/tags"> tags</a>
        </li>
      

         
      
      
        <li>
          <span class="counter-menu">5</span>
          <svg viewBox="0 0 50 50" class="icon-arrow-menu"><use xlink:href="#icon-right-arrow"></use></svg>
          <a href="http://localhost:4000/about"> about me</a>
        </li>
      

         
      
    </ul>

    <ul>
      <li><span class="counter-menu">g</span><svg viewBox="0 0 50 50" class="icon-arrow-menu"><use xlink:href="#icon-right-arrow"></use></svg><a title="Show my projects on GitHub"  target="_blank" href="http://github.com/LouSeoi" class="search">github</a></li>
      <li><span class="counter-menu">s</span><svg viewBox="0 0 50 50" class="icon-arrow-menu"><use xlink:href="#icon-right-arrow"></use></svg><a  title="Search for a post" class="search">search</a></li>
      <li><span class="counter-menu">t</span><svg viewBox="0 0 50 50" class="icon-arrow-menu"><use xlink:href="#icon-right-arrow"></use></svg><a title="Follow me in Twitter" target="_blank" href="http://twitter.com/RiziaGXY">twitter</a></li>
    </ul>
  </nav>
</aside>

<a id="search" class="dosearch">
    <svg class="icon-menu icon-search"><use xlink:href="#icon-search"></use></svg>
</a>

</header>

        <div class="tree-posts">

    <h3>*Posts*</h3>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/db/">
                <h2 class="post-title" itemprop="name">PostgreSQL索引设计底层分析.md</h2>
            </a>
        </div>
    </article>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/unixfs/">
                <h2 class="post-title" itemprop="name">Unix-FileSystem-project.md</h2>
            </a>
        </div>
    </article>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/testofxc/">
                <h2 class="post-title" itemprop="name">携程面经.md</h2>
            </a>
        </div>
    </article>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/system/">
                <h2 class="post-title" itemprop="name">note-of-Computer-System.md</h2>
            </a>
        </div>
    </article>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/network/">
                <h2 class="post-title" itemprop="name">note-of-Network.md</h2>
            </a>
        </div>
    </article>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/datastructure/">
                <h2 class="post-title" itemprop="name">note-of-Data-Structure.md</h2>
            </a>
        </div>
    </article>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/algorithm/">
                <h2 class="post-title" itemprop="name">note-of-Algorithm.md</h2>
            </a>
        </div>
    </article>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/testoftx/">
                <h2 class="post-title" itemprop="name">腾讯笔经.md</h2>
            </a>
        </div>
    </article>

    

    <article role="article" class="post-item" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
        <div class="content">
            <a title="Open the post" href="/coding/">
                <h2 class="post-title" itemprop="name">Half-month-in-Leetcode.md</h2>
            </a>
        </div>
    </article>

    

</div>

        <section class="post" itemscope itemtype="http://schema.org/BlogPosting">
            
                <div class="time">
                    <time itemprop="datePublished" datetime="2017-03-29 08:33:31 +0800">29 Mar 2017</time>
                </div>
            
            <h1 class="post-title" itemprop="name">Half month in Leetcode</h1>

            <article role="article" id="scroll" class="post-content" itemprop="articleBody">
                <h1 id="1">1</h1>
<ul>
  <li>问题描述 ：删除一个数组内某个字符 不能另开空间，返回数组长度。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int removeElement(vector&lt;int&gt;&amp; nums, int val) {
int i = 0;
int j = 0;
int size = nums.size();
for(;i &lt; size;i++)
{
if(nums[i] == val)
continue;
nums[j] = nums[i];
j++;
}
return j;
}
};
</code></pre>
    </div>
    <h1 id="2">2</h1>
  </li>
  <li>已经排序好的一个数组</li>
  <li>因为已经排序，所以每次找到后一个跟他不一样的数字即可。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int removeDuplicates(vector&lt;int&gt;&amp; nums) {
int i = 0;
int j = 0;
int n = nums.size();
if(n &lt; 2)
return n;
for(i = j + 1;i &lt; n;i++)
{
if(nums[i] == nums[j])
continue;
nums[++j] = nums[i];
}
return j+1;
}
};
</code></pre>
    </div>
    <h1 id="3">3</h1>
  </li>
  <li>排序数组，允许一个数至多出现两次。</li>
  <li>设置一个计数位置即可，即从后往前复制时要复制两个。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int removeDuplicates(vector&lt;int&gt;&amp; nums) {
int i = 0;
int j = 0;
int count = 0;
int n = nums.size();
if(n &lt; 2)
return n;
for(i = j + 1;i &lt; n;i++)
{
if(nums[i] == nums[j]){
if(++count &lt; 2)
nums[++j] = nums[i];
}
else
{
count = 0;
nums[++j] = nums[i];
}
}
return j+1;
}
};
</code></pre>
    </div>
    <h1 id="4">4</h1>
  </li>
  <li>数组加一
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
int i = digits.size() - 1;
int one = 1;
for(;i&gt;=0 &amp;&amp; one &gt; 0;i--)
{
int temp = (digits[i] + one)/10;
digits[i] = (digits[i] + one)%10;
one = temp;
}
if(one == 1)
digits.insert(digits.begin(),1);
return digits;
}
};
</code></pre>
    </div>
    <h1 id="5">5</h1>
  </li>
  <li>pascal三角形</li>
  <li>vector resize注意
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
vector&lt;vector&lt;int&gt;&gt; result;
result.resize(numRows);
for(int i = 0;i &lt; numRows;i++)
{
result[i].resize(i+1);
result[i][0] = 1;
result[i][i] = 1;
for(int j = 1;j &lt; i;j++)
{
result[i][j] = result[i-1][j-1] + result[i-1][j]; 
}
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="6">6</h1>
  </li>
  <li>pascal只输出一行
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
vector&lt;int&gt; getRow(int rowIndex) {
vector&lt;int&gt; result;
result.resize(rowIndex+1,1);
for(int i = 0;i &lt;= rowIndex;i++)
{
for(int j = (i &gt; 1?i-1:0);j &gt; 0;j--)
{
result[j] = result[j-1] + result[j];
}
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="7">7</h1>
  </li>
  <li>merge sort
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
nums1.resize(m);
int i,j;
for(i = 0,j = 0;i &lt; m &amp;&amp; j &lt; n;)
{
if(nums1[i] &gt; nums2[j]){
nums1.insert(nums1.begin()+i,nums2[j]);
j++;
m++;
i++;
}
else{
i++;
}
}
for(;j&lt;n;j++)
{
nums1.push_back(nums2[j]);
}
}
};
</code></pre>
    </div>
    <h1 id="8">8</h1>
  </li>
  <li>two sum
    <div class="highlighter-rouge"><pre class="highlight"><code># include &lt;map&gt;
class Solution {
public:
vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
int i = 0;
map&lt;int,int&gt; a;
vector&lt;int&gt; result;
int j = nums.size() - 1;
for(int i = 0;i&lt;nums.size();i++)
{
int jian = target - nums[i];
if(a.find(jian)!=a.end())
{
result.push_back(a[jian]);
result.push_back(i);
return result;
}
else
{
a[nums[i]] = i;
}
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="9">9</h1>
  </li>
  <li>three sum</li>
  <li>!!!!! int 和 unsigned int的转换
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void qsort(vector&lt;int&gt;&amp; nums,int low,int high)
{
if(low&gt;=high)
return;
int key = nums[low];
int i = low;
int j = high;
while(i&lt;j)
{
for(;i&lt;j&amp;&amp;nums[j]&gt;=key;j--);
nums[i] = nums[j];
for(;i&lt;j&amp;&amp;nums[i]&lt;=key;i++);
nums[j] = nums[i];
}
nums[j] = key;
qsort(nums,low,j-1);
qsort(nums,j+1,high);
}
vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
vector&lt;vector&lt;int&gt;&gt; result;
qsort(nums,0,int(nums.size()-1));
for(int i = 0;i &lt; int(nums.size()-2);)
{
int j = i+1;
int k = nums.size()-1;
for(;j&lt;k;)
{
if(nums[i]+nums[j]+nums[k] == 0)
{
vector&lt;int&gt; cur;
cur.push_back(nums[i]);
cur.push_back(nums[j]);
cur.push_back(nums[k]);
result.push_back(cur);
j++;
k--;
while(k&gt;=i&amp;&amp;nums[k]==nums[k+1])
k--;
while(j&lt;k&amp;&amp;nums[j]==nums[j-1])
j++;
}
else if(nums[i]+nums[j]+nums[k] &gt; 0)
{
k--;
}
else
j++;
}
i++;
while((i&lt;nums.size()-2)&amp;&amp;nums[i-1] == nums[i])
i++;
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="10">10</h1>
  </li>
  <li>3 sum closest</li>
  <li>跟3 sum思路比较相似
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
# include &lt;math.h&gt;
void qsort(vector&lt;int&gt;&amp; nums,int low,int high)
{
if(low&gt;=high)
return;
int key = nums[low];
int i = low;
int j = high;
while(i&lt;j)
{
for(;i&lt;j&amp;&amp;nums[j]&gt;=key;j--);
nums[i] = nums[j];
for(;i&lt;j&amp;&amp;nums[i]&lt;=key;i++);
nums[j] = nums[i];
}
nums[j] = key;
qsort(nums,low,j-1);
qsort(nums,j+1,high);
}
int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
vector&lt;int&gt; result;
qsort(nums,0,int(nums.size()-1));
int minus = 0;
int min = 99999999;
for(int i = 0;i &lt; int(nums.size()-2);)
{
int j = i+1;
int k = nums.size()-1;
for(;j&lt;k;)
{
minus = nums[i]+nums[j]+nums[k]-target;
if(minus == 0)
{
return target;
while(k&gt;=i&amp;&amp;nums[k]==nums[k+1])
k--;
while(j&lt;k&amp;&amp;nums[j]==nums[j-1])
j++;
}
else if(minus &gt; 0)
{
k--;
}
else
j++;
if(fabs(minus)&lt;fabs(min))
{
min = minus;
}
}
i++;
while((i&lt;nums.size()-2)&amp;&amp;nums[i-1] == nums[i])
i++;
}
return target+min;
}
};
</code></pre>
    </div>
    <h1 id="11">11</h1>
  </li>
  <li>four Sum
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void qsort(vector&lt;int&gt;&amp; nums,int low,int high)
{
if(low&gt;=high)
return;
int key = nums[low];
int i = low;
int j = high;
while(i&lt;j)
{
for(;i&lt;j&amp;&amp;nums[j]&gt;=key;j--);
nums[i] = nums[j];
for(;i&lt;j&amp;&amp;nums[i]&lt;=key;i++);
nums[j] = nums[i];
}
nums[j] = key;
qsort(nums,low,j-1);
qsort(nums,j+1,high);
}
vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums,int target) {
vector&lt;vector&lt;int&gt;&gt; result;
qsort(nums,0,int(nums.size()-1));
for(int i = 0;i &lt; int(nums.size()-3);)
{
for(int j = i+1;j&lt;int(nums.size()-2);)
{
int k = nums.size()-1;
int l = j+1;
for(;l&lt;k;)
{
if(nums[i]+nums[j]+nums[k]+nums[l]== target)
{
vector&lt;int&gt; cur;
cur.push_back(nums[i]);
cur.push_back(nums[j]);
cur.push_back(nums[l]);
cur.push_back(nums[k]);
result.push_back(cur);
l++;
k--;
while(k&gt;l&amp;&amp;nums[k]==nums[k+1])
k--;
while(l&lt;k&amp;&amp;nums[l]==nums[l-1])
l++;
}
else if(nums[i]+nums[j]+nums[k]+nums[l] &gt; target)
{
k--;
}
else
l++;
}
j++;
while((j&lt;nums.size()-2)&amp;&amp;nums[j-1] == nums[j])
j++;
}
i++;
while((i&lt;nums.size()-3)&amp;&amp;nums[i-1] == nums[i])
i++;
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="12">12</h1>
  </li>
  <li>在一个排序数组（循环）内找到最小的数字。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int erfen(vector&lt;int&gt;&amp; nums,int low,int high)
{
if(low&gt;=high)
return nums[low];
int mid = (low+high)/2;
if(mid == low)
{
return nums[low]&gt;nums[high]?nums[high]:nums[low];
}
if(nums[mid] &gt; nums[high])
return erfen(nums,mid,high);
else if(nums[mid] &lt; nums[low])
return erfen(nums,low,mid);
else
return nums[low];
}
int findMin(vector&lt;int&gt;&amp; nums) {
if(nums.size()&lt;=0)
return 0;
return erfen(nums,0,int(nums.size()-1));
}
};
</code></pre>
    </div>
    <h1 id="13">13</h1>
  </li>
  <li>存在重复元素上一题</li>
  <li>重要的点在于判断中间首尾的元素，如果中间的比尾数小，那么肯定也比首尾小，进入循环，所以之存在一种首尾中间元素相等的情况，那么把首位元素去除再查找即可，加入判断，如果首尾比末尾小，即已经排序好了，直接返回低位。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int erfen(vector&lt;int&gt;&amp; nums,int low,int high)
{
if(low&gt;=high)
return nums[low];
if(nums[low] &lt; nums[high])
return nums[low];
int mid = (low+high)/2;
if(mid == low)
{
return nums[low]&gt;nums[high]?nums[high]:nums[low];
}
if(nums[mid] &gt; nums[high])
return erfen(nums,mid,high);
else if(nums[mid] &lt; nums[low])
return erfen(nums,low,mid);
else
return erfen(nums,low+1,high);
}
int findMin(vector&lt;int&gt;&amp; nums) {
if(nums.size()==0)
return 0;
return erfen(nums,0,nums.size()-1);
}
};
</code></pre>
    </div>
    <h1 id="14">14</h1>
  </li>
  <li>直方图计算最大的矩形</li>
  <li>这一题很考验算法，这题的思路是构建一个递增的长条，然后分开计算矩形的面积，在原本的直方图最后插入一个长度为0的方块，这样可以保证最后输出的值是之前的方块的最大值。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
vector&lt;int&gt; s;
if(heights.size()&lt;1)
return 0;
int sum = heights[0];
heights.push_back(0);
for(int i = 0;i&lt;heights.size();)
{
if(s.empty()||heights[i]&gt;heights[s.back()])
{
s.push_back(i);
i++;
}
else
{
int t = s.back();
s.pop_back();
int mianji = heights[t] * (s.empty()?i:(i-s.back()-1));
if(mianji &gt; sum)
sum = mianji;
}
}
return sum;
}
};
</code></pre>
    </div>
    <h1 id="15">15</h1>
  </li>
  <li>01矩阵，求最大的1的面积</li>
  <li>相当于每行转换为直方图，求直方图的面积最大，跟上一题一样。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int largeRectangle(vector&lt;int&gt; height)
{
int sum = 0;
height.push_back(0);
vector&lt;int&gt; s;
for(int i = 0;i&lt;height.size();)
{
if(s.empty()||height[i]&gt;height[s.back()])
{
s.push_back(i);
i++;
}
else
{
int t = s.back();
s.pop_back();
int mianji = height[t]*(s.empty()?i:i-s.back()-1);
if(mianji &gt; sum)
sum = mianji;
}
}
return sum;
}
int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
if(matrix.size()&lt;1)
return 0;
vector&lt;int&gt; cur_height;
for(int i = 0;i&lt;matrix[0].size();i++)
{
if(matrix[0][i] == '1')
cur_height.push_back(1);
else
cur_height.push_back(0);
}
int sum = largeRectangle(cur_height);
for(int i = 1;i&lt;matrix.size();i++)
{
for(int j = 0;j&lt;matrix[i].size();j++)
{
if(matrix[i][j] == '1')
cur_height[j] += 1;
else
cur_height[j] = 0;
}
int temp = largeRectangle(cur_height);
if(temp &gt; sum)
sum = temp;
}
return sum;
}
};
</code></pre>
    </div>
    <h1 id="16">16</h1>
  </li>
  <li>回文数字
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool isPalindrome(int x) {
if(x&lt;0)
return 0;
else
{
int temp_x = x;
int sum = 0;
while(temp_x&gt;0)
{
sum = sum*10 + temp_x % 10;
temp_x/=10;
}
if(sum==x)
return 1;
return 0;
}
}
};
</code></pre>
    </div>
    <h1 id="17">17</h1>
  </li>
  <li>判断一个数字在矩阵中是否存在
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
if(matrix.size()&lt;1)
return false;
int i = 0;
int j = matrix[0].size()-1;
for(;i&lt;matrix.size()&amp;&amp;j&gt;=0;)
{
if(matrix[i][j] &gt; target)
j--;
else if(matrix[i][j] &lt; target)
i++;
else
return 1;
}
return 0;
}
};
</code></pre>
    </div>
    <h1 id="18">18</h1>
  </li>
  <li>查找target出现的区间
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int erfenleft(vector&lt;int&gt;&amp; nums,int target,int low,int high)
{
if(low&gt;=high)
return nums[low] == target?low:-1;
int mid = (low+high)/2;
if(mid==low)
return nums[low] == target?low:(nums[high] == target?high:-1);
if(nums[mid]&gt;=target)
return erfenleft(nums,target,low,mid);
else
return erfenleft(nums,target,mid,high);
}
int erfenright(vector&lt;int&gt;&amp; nums,int target,int low,int high)
{
if(low&gt;=high)
return low;
int mid = (low+high)/2;
if(mid==low)
return nums[high] == target?high:(nums[low] == target?low:-1);
if(nums[mid]&lt;=target)
return erfenright(nums,target,mid,high);
else
return erfenright(nums,target,low,mid);
}
vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
if(nums.size()==0)
return vector&lt;int&gt;({-1,-1});
int high = nums.size()-1;
int left = erfenleft(nums,target,0,high);
if(left == -1)
return vector&lt;int&gt;({-1,-1});
int right = erfenright(nums,target,left,high);
if(right == -1)
return vector&lt;int&gt;({-1,-1});
return vector&lt;int&gt;({left,right});
}
};
</code></pre>
    </div>
    <h1 id="19">19</h1>
  </li>
  <li>二分查找插入位置
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int erfen(vector&lt;int&gt;nums,int target,int low,int high)
{
if(low &gt;= high)
return target&gt;nums[low]?low+1:low;
int mid = (low+high)/2;
if(target &gt; nums[mid])
return erfen(nums,target,mid+1,high);
else if(target &lt; nums[mid])
return erfen(nums,target,low,mid-1);
return mid;
}
int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
return erfen(nums,target,0,int(nums.size()-1));
}
};
</code></pre>
    </div>
    <h1 id="20">20</h1>
  </li>
  <li>找到一个peak number，即他的值大于左右两个邻居。</li>
  <li>用二分法，因为最左边和最后边最小，所以当左边比中间大时，左边肯定存在一个peak，同理右边也是一样。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int erfen(vector&lt;int&gt; nums,int low,int high)
{
if(low&gt;=high)
return low;
int mid = (low + high)/2;
if((mid==0||nums[mid]&gt;=nums[mid-1]) &amp;&amp; ((mid==nums.size()-1) || nums[mid]&gt;=nums[mid+1]))
return mid;
else if(mid &gt; 0 &amp;&amp; nums[mid]&lt;nums[mid-1])
return erfen(nums,low,mid-1);
else
return erfen(nums,mid+1,high);
}
int findPeakElement(vector&lt;int&gt;&amp; nums) {
if(nums.size()&lt;1)
return 0;
return erfen(nums,0,nums.size()-1);
}
};
</code></pre>
    </div>
    <h1 id="21-missing-number">21 missing number</h1>
  </li>
  <li>全部异或
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int missingNumber(vector&lt;int&gt;&amp; nums) {
if(nums.size()&lt;1)
return 0;
int result = 0;
for(int i = 0;i&lt;nums.size();i++)
{
result = result^nums[i]^i;
}
return result^(nums.size());
}
};
</code></pre>
    </div>
    <h1 id="22-pow-of-two">22 pow of two</h1>
  </li>
  <li>判断是不是2的幂
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool isPowerOfTwo(int n) {
bool hasone = 0;
if(n &lt;= 0)
return 0;
while(n!=0)
{
if(n&amp;1)
{
if(hasone)
return 0;
else
hasone = 1;
}
n = n&gt;&gt;1;
}
return true;
}
};
</code></pre>
    </div>
    <h1 id="23-hammingweight">23 hammingWeight</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int hammingWeight(uint32_t n) {
int count = 0;
for(;n!=0;n=n&gt;&gt;1)
{
if(n&amp;1)
count++;
}
return count;
}
};
</code></pre>
    </div>
    <h1 id="24-二叉树最大深度">24 二叉树最大深度</h1>
    <p>```
/**</p>
  </li>
  <li>Definition for a binary tree node.</li>
  <li>struct TreeNode {</li>
  <li>int val;</li>
  <li>TreeNode *left;</li>
  <li>TreeNode *right;</li>
  <li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
  <li>};
<em>/
class Solution {
public:
int DepthSearch(TreeNode *root,int depth)
{
if(root == NULL)
return depth-1;
int left_depth = DepthSearch(root-&gt;left,depth+1);
int right_depth = DepthSearch(root-&gt;right,depth+1);
return left_depth&gt;right_depth?left_depth:right_depth;
}
int maxDepth(TreeNode</em> root) {
return DepthSearch(root,1);
}
};
    <div class="highlighter-rouge"><pre class="highlight"><code># 25 最小深度
</code></pre>
    </div>
    <p>class Solution {
public:
int DepthSearch(TreeNode <em>root,int depth)
{
if(!root-&gt;left &amp;&amp; !root-&gt;right)
return depth;
int left_depth = root-&gt;left==NULL?999999:DepthSearch(root-&gt;left,depth+1);
int right_depth = root-&gt;right==NULL?999999:DepthSearch(root-&gt;right,depth+1);
return left_depth&gt;right_depth?right_depth:left_depth;
}
int minDepth(TreeNode</em> root) {
if(!root)
return 0;
if(!root-&gt;left &amp;&amp; !root-&gt;right)
return 1;
else if(!root-&gt;left)
return DepthSearch(root-&gt;right,2);
else if(!root-&gt;right)
return DepthSearch(root-&gt;left,2);
return DepthSearch(root,1);
}
};
```</p>
    <h1 id="26-从后序遍历中序遍历建树">26 从后序遍历中序遍历建树</h1>
  </li>
  <li>递归爆内存，用引用传入参数，完美解决问题。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
map&lt;int,int&gt; m;
TreeNode* create(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder,int in_s,int in_e,int post_s,int post_e)
{
if(in_s &gt; in_e || post_s &gt; post_e)
return NULL;
TreeNode* root = new TreeNode(postorder[post_e]);
int mid = m[postorder[post_e]];
int num = mid - in_s;
root-&gt;left = create(inorder,postorder,in_s,mid-1,post_s,post_s+num-1);
root-&gt;right = create(inorder,postorder,mid+1,in_e,post_s+num,post_e-1);
return root;
}
TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
if(inorder.empty() || postorder.empty())
return NULL;
for(int i = 0;i &lt; inorder.size();i++)
m[inorder[i]] = i;
return create(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);
}
};
</code></pre>
    </div>
    <h1 id="27-前序中序">27 前序中序</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
map&lt;int,int&gt; m;
TreeNode* create(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;preorder,int in_s,int in_e,int pre_s,int pre_e)
{
if(in_s &gt; in_e || pre_s &gt; pre_e)
return NULL;
TreeNode* root = new TreeNode(preorder[pre_s]);
int mid = m[preorder[pre_s]];
int num = mid - in_s;
root-&gt;left = create(inorder,preorder,in_s,mid-1,pre_s+1,pre_s+num);
root-&gt;right = create(inorder,preorder,mid+1,in_e,pre_s+num+1,pre_e);
return root;
}
TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
if(inorder.empty() || preorder.empty())
return NULL;
for(int i = 0;i &lt; inorder.size();i++)
m[inorder[i]] = i;
return create(inorder,preorder,0,inorder.size()-1,0,preorder.size()-1);
}
};
</code></pre>
    </div>
    <h1 id="28-深度遍历">28 深度遍历</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void Traversal(TreeNode* root,int level,vector&lt;vector&lt;int&gt;&gt; &amp;result)
{
if(root == NULL)
return;
if(level &gt; result.size())
result.resize(level);
result[level-1].push_back(root-&gt;val);
Traversal(root-&gt;left,level+1,result);
Traversal(root-&gt;right,level+1,result);
}
vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
vector&lt;vector&lt;int&gt;&gt; result;
Traversal(root,1,result);
return result;
}
};
</code></pre>
    </div>
    <h1 id="29-深度遍历翻过来存储">29 深度遍历，翻过来存储</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void Traversal(TreeNode* root,int level,vector&lt;vector&lt;int&gt;&gt; &amp;result)
{
if(root == NULL)
return;
if(level &gt; result.size())
{
vector&lt;int&gt; new_one;
result.insert(result.begin(),new_one);
}
result[result.size()-level].push_back(root-&gt;val);
Traversal(root-&gt;left,level+1,result);
Traversal(root-&gt;right,level+1,result);
}
vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
vector&lt;vector&lt;int&gt;&gt; result;
Traversal(root,1,result);
return result;
}
};
</code></pre>
    </div>
    <h1 id="30-深度遍历单层翻转输出">30 深度遍历，单层翻转输出</h1>
  </li>
  <li>reverse函数的运用
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void Traversal(TreeNode* root,int level,vector&lt;vector&lt;int&gt;&gt; &amp;result)
{
if(root == NULL)
return;
if(level &gt; result.size())
result.resize(level);
result[level-1].push_back(root-&gt;val);
Traversal(root-&gt;left,level+1,result);
Traversal(root-&gt;right,level+1,result);
}
vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
vector&lt;vector&lt;int&gt;&gt; result;
Traversal(root,1,result);
for(int i = 0;i&lt;result.size();i++)
{
if(i&amp;1)
reverse(result[i].begin(),result[i].end());
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="31-镜像树">31 镜像树</h1>
  </li>
  <li>树的操作尽量往递归的方面想，递归也一样。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool checkTree(TreeNode *left,TreeNode *right)
{
if(!left&amp;&amp;!right)
return true;
else if(!left||!right)
return false;
bool con1 = left-&gt;val == right-&gt;val;
return con1 &amp; checkTree(left-&gt;right,right-&gt;left) &amp; checkTree(left-&gt;left,right-&gt;right);
}
bool isSymmetric(TreeNode* root) {
if(!root)
return 1;
return checkTree(root-&gt;left,root-&gt;right);
}
};
</code></pre>
    </div>
    <h1 id="32-判断两棵树是否相等">32 判断两棵树是否相等</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool isSameTree(TreeNode* p, TreeNode* q) {
if(!p&amp;&amp;!q)
return true;
if(!p||!q)
return false;
return p-&gt;val==q-&gt;val&amp;&amp;isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);
}
};
</code></pre>
    </div>
    <h1 id="33-判断是否为平衡二叉树">33 判断是否为平衡二叉树</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int depthSearch(TreeNode* root,int depth)
{
if(root == NULL)
return depth-1;
int left_height = depthSearch(root-&gt;left,depth+1);
if(left_height == -1)
return -1;
int right_height = depthSearch(root-&gt;right,depth+1);
if(right_height == -1)
return -1;
int diff = left_height&gt;right_height?left_height-right_height:right_height-left_height;
if(diff &gt; 1)
return -1;
return left_height&gt;right_height?left_height:right_height;
}
bool isBalanced(TreeNode* root) {
if(root == NULL)
return true;
if(depthSearch(root,1) == -1)
return 0;
return true;
}
};
</code></pre>
    </div>
    <h1 id="34-判断是否存在一个路径和为sum">34 判断是否存在一个路径和为sum</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool equalSum(TreeNode *root,int sum,int target)
{
sum+=root-&gt;val;
if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
return sum==target;
bool left = root-&gt;left==0?0:equalSum(root-&gt;left,sum,target);
bool right = root-&gt;right==0?0:equalSum(root-&gt;right,sum,target);
return left||right;
}
bool hasPathSum(TreeNode* root, int sum) {
if(root == NULL)
return false;
return equalSum(root,0,sum);
}
};
</code></pre>
    </div>
    <h1 id="35-用栈模拟前序遍历">35 用栈模拟前序遍历</h1>
  </li>
  <li>一般递归的过程都可以用栈来模拟。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
vector&lt;int&gt; preorderTraversal(TreeNode* root) {
vector&lt;TreeNode *&gt; node;
vector&lt;int&gt; result;
TreeNode *cur = root;
if(root)
node.push_back(root);
while(!node.empty())
{
cur = node.back();
node.pop_back();
result.push_back(cur-&gt;val);
if(cur-&gt;right)
node.push_back(cur-&gt;right);
if(cur-&gt;left)
node.push_back(cur-&gt;left);
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="36-非递归实现中序遍历">36 非递归实现中序遍历</h1>
  </li>
  <li>先压入左子树，然后再判断到左子树的叶子结点则弹出处理，压入右子树
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
vector&lt;int&gt; inorderTraversal(TreeNode* root) {
vector&lt;TreeNode *&gt;node;
vector&lt;int&gt; result;
TreeNode *cur;
if(root)
node.push_back(root);
while(!node.empty())
{
cur = node.back();
while(cur){
if(cur-&gt;left)
node.push_back(cur-&gt;left);
cur = cur-&gt;left;
}
if(!node.empty()){
if(!node.back())
node.pop_back();
if(!node.empty()){
cur = node.back();
result.push_back(cur-&gt;val);
node.pop_back();
node.push_back(cur-&gt;right);
}
}
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="37-非递归实现后序排列">37 非递归实现后序排列</h1>
  </li>
  <li>重要是判断出栈条件，是叶子结点或者上一次弹出来的是他的叶子结点，则弹出来。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
vector&lt;int&gt; postorderTraversal(TreeNode* root) {
vector&lt;TreeNode *&gt; node;
vector&lt;int&gt; result;
TreeNode *cur = root;
TreeNode *pre = NULL;
if(root)
node.push_back(root);
while(!node.empty())
{
cur = node.back();
if((!cur-&gt;left&amp;&amp;!cur-&gt;right) ||(pre!=NULL&amp;&amp;(pre == cur-&gt;left || pre == cur-&gt;right)))
{
result.push_back(cur-&gt;val);
node.pop_back();
pre = cur;
}
else
{
if(cur-&gt;right)
node.push_back(cur-&gt;right);
if(cur-&gt;left)
node.push_back(cur-&gt;left);
}
}
return result;
}
};
</code></pre>
    </div>
    <h1 id="38-每一层链表练起来">38 每一层链表练起来</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void connect(TreeLinkNode *root) {
if(!root)
return;
TreeLinkNode *dad = root;
while(dad-&gt;left)
{
TreeLinkNode *temp_dad = dad;
while(temp_dad)
{
temp_dad-&gt;left-&gt;next = temp_dad-&gt;right;
temp_dad-&gt;right-&gt;next = temp_dad-&gt;next!=NULL?temp_dad-&gt;next-&gt;left:NULL;
temp_dad = temp_dad-&gt;next;
}
dad = dad-&gt;left;
}
}
};
</code></pre>
    </div>
    <h1 id="39-非完全二叉树每一层连起来">39 非完全二叉树每一层连起来</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void connect(TreeLinkNode *root) {
if(!root)
return;
TreeLinkNode *dad = root;
while(dad)
{
TreeLinkNode *temp_dad = dad;
TreeLinkNode *last = NULL;
bool huaceng = 0;
while(temp_dad)
{
if(temp_dad-&gt;left){
if(last==NULL)
{
last = temp_dad-&gt;left;
dad = last;
huaceng = 1;
}
else{
last-&gt;next = temp_dad-&gt;left;
last = temp_dad-&gt;left;
}
}
if(temp_dad-&gt;right){
if(last==NULL)
{
last = temp_dad-&gt;right;
dad = last;
huaceng = 1;
}
else
{
last-&gt;next = temp_dad-&gt;right;
last = temp_dad-&gt;right;
}
}
temp_dad = temp_dad-&gt;next;
}
if(huaceng == 0)
dad = dad-&gt;next;
}
}
};
</code></pre>
    </div>
    <h1 id="40-排序链表到平衡搜索树">40 排序链表到平衡搜索树</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
TreeNode* convert(ListNode *head,ListNode *end)
{
if(head == end)
return NULL;
ListNode *slow = head;
ListNode *fast = head;
while(fast!= end &amp;&amp; fast-&gt;next != end)
{
fast = fast-&gt;next-&gt;next;
slow = slow-&gt;next;
}
TreeNode *root = new TreeNode(slow-&gt;val);
root-&gt;left =  convert(head,slow);
root-&gt;right =  convert(slow-&gt;next,end);
return root;
}
TreeNode* sortedListToBST(ListNode* head) {
return convert(head,NULL);
}
};
</code></pre>
    </div>
    <h1 id="41-path-sum-ii">41 path sum II</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void path(vector&lt;vector&lt;int&gt;&gt; &amp;result,vector&lt;int&gt; cur,TreeNode *root,int sum,int target)
{
cur.push_back(root-&gt;val);
sum += root-&gt;val;
if(sum == target &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)
{
result.push_back(cur);
}
if(root-&gt;left)
path(result,cur,root-&gt;left,sum,target);
if(root-&gt;right)
path(result,cur,root-&gt;right,sum,target);
}
vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
vector&lt;vector&lt;int&gt;&gt; result;
vector&lt;int&gt; cur;
if(!root)
return result;
path(result,cur,root,0,sum);
return result;
}
};
</code></pre>
    </div>
    <h1 id="42-前序遍历到单侧树">42 前序遍历到单侧树</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void flatten(TreeNode* root) {
vector&lt;TreeNode*&gt; node_stack;
if(root)
node_stack.push_back(root);
TreeNode *pre = NULL;
while(!node_stack.empty())
{
TreeNode* temp = node_stack.back();
node_stack.pop_back();
if(!pre)
pre = temp;
else{
pre-&gt;right = temp;
pre-&gt;left = NULL;
pre = temp;
}
if(temp-&gt;right)
node_stack.push_back(temp-&gt;right);
if(temp-&gt;left)
node_stack.push_back(temp-&gt;left);
}
}
};
</code></pre>
    </div>
    <h1 id="43-判断是否为二叉搜索树">43 判断是否为二叉搜索树</h1>
  </li>
  <li>函数的关键在于告诉他这个点应该的取值范围是多少。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool judge(TreeNode *root,long long min,long long max)
{
if(!root)
return true;
if(root-&gt;val &gt;= max || root-&gt;val &lt;= min)
return false;
else
return judge(root-&gt;right,root-&gt;val,max) &amp;&amp; judge(root-&gt;left,min,root-&gt;val);
}
bool isValidBST(TreeNode* root) {
if(!root)
return true;
return judge(root,numeric_limits&lt;long long&gt;::min(),numeric_limits&lt;long long&gt;::max());
}
};
</code></pre>
    </div>
    <h1 id="44-o1-空间中序遍历--线索树-好难">44 o(1) 空间中序遍历  线索树 好难！！</h1>
  </li>
  <li>如果左子树不为空，找到前驱元素，右孩子的右指针设为当前遍历的元素（如果已经设置则置NULL，cur往右走）。</li>
  <li>如果左子树为空，往右走。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
void recoverTree(TreeNode* root) {
TreeNode* cur = NULL;
TreeNode* pre = NULL;
TreeNode* p1 = NULL;
TreeNode* p2 = NULL;
TreeNode* preCur = NULL;
bool found = 0;
if(!root)
return;
cur = root;
while(cur){
if(!cur-&gt;left){
if(preCur &amp;&amp; preCur-&gt;val &gt; cur-&gt;val)
{
if(!found){
p1 = preCur;
found = true;
}
p2 = cur;
}
preCur = cur;
cur = cur-&gt;right;
}
else{
pre = cur-&gt;left;
while(pre-&gt;right &amp;&amp; pre-&gt;right != cur)
pre = pre-&gt;right;
if(!pre-&gt;right)
{
pre-&gt;right = cur;
cur = cur-&gt;left;
}
else
{
if(preCur-&gt;val &gt; cur-&gt;val){
if(!found){
p1 = preCur;
found = true;
}
p2 = cur;
}
preCur = cur;
pre-&gt;right = NULL;
cur = cur-&gt;right;
}
}
}
if(p1 &amp;&amp; p2){
int temp = p1-&gt;val;
p1-&gt;val = p2-&gt;val;
p2-&gt;val = temp;
}
}
};
</code></pre>
    </div>
    <h1 id="45-输出所有路径">45 输出所有路径</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
string int2string(vector&lt;int&gt; path)
{
stringstream s;
int i = 0;
for(i = 0;i&lt;(path.size()-1);i++)
s &lt;&lt; path[i] &lt;&lt; "-&gt;";
s &lt;&lt; path[i];
return s.str();
}
void findpath(TreeNode *root,vector&lt;string&gt; &amp;result,vector&lt;int&gt; cur)
{
if(!root)
return;
cur.push_back(root-&gt;val);
if(!root-&gt;left&amp;&amp;!root-&gt;right)
result.push_back(int2string(cur));
if(root-&gt;left)
findpath(root-&gt;left,result,cur);
if(root-&gt;right)
findpath(root-&gt;right,result,cur);
}
vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
vector&lt;string&gt; result;
if(!root)
return result;
vector&lt;int&gt; cur;
findpath(root,result,cur);
return result;
}
};
</code></pre>
    </div>
    <h1 id="46-输出路径和">46 输出路径和</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int vec2num(vector&lt;int&gt; cur)
{
int sum = 0;
for(int i = 0;i &lt; cur.size();i++)
sum = sum * 10 + cur[i];
return sum;
}
void depthsearch(TreeNode *root,int &amp;sum,vector&lt;int&gt; cur)
{
if(!root)
return;
cur.push_back(root-&gt;val);
if(!root-&gt;left&amp;&amp;!root-&gt;right)
{
sum += vec2num(cur);
return;
}
if(root-&gt;left)
depthsearch(root-&gt;left,sum,cur);
if(root-&gt;right)
depthsearch(root-&gt;right,sum,cur);
}
int sumNumbers(TreeNode* root) {
int sum = 0;
vector&lt;int&gt; cur;
depthsearch(root,sum,cur);
return sum;
}
};
</code></pre>
    </div>
    <h1 id="47-卖股票">47 卖股票</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int maxProfit(vector&lt;int&gt;&amp; prices) {
if(prices.size() &lt; 2)
return 0;
int min_point = prices[0];
int profit = prices[1] - prices[0];
for(int i = 1;i &lt; prices.size();i++)
{
min_point = min(min_point,prices[i]);
profit = max(profit,prices[i] - min_point);
}
return profit&gt;0?profit:0;
}
};
</code></pre>
    </div>
    <h1 id="48-卖股票2">48 卖股票2</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int maxProfit(vector&lt;int&gt;&amp; prices) {
int profit = 0;
if(prices.size() &lt; 2)
return 0;
int min = prices[0];
for(int i = 1;i &lt; prices.size();i++)
{
if(prices[i] &gt; prices[i-1]){
profit += prices[i]- prices[i-1];
}
}
return profit;
}
};
</code></pre>
    </div>
    <h1 id="49-卖股票3">49 卖股票3</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int maxProfit(vector&lt;int&gt; &amp;prices) {
int len = (int)prices.size();
if(len &lt;= 1) {
return 0;
} 
vector&lt;int&gt; profits;
profits.resize(len);
//首先我们正向遍历得到每天一次交易的最大收益
//并保存到profits里面
int minP = prices[0];
int sum = numeric_limits&lt;int&gt;::min();
for(int i = 1; i &lt; len; i++) {
minP = min(minP, prices[i - 1]);
Best Time To Buy And Sell Stock 83profits[i] = max(sum, prices[i] - minP);
sum = profits[i];
} 
int maxP = prices[len - 1];
int sum2 = numeric_limits&lt;int&gt;::min();
//逆向遍历
for(int i = len - 2; i &gt;= 0; i--) {
maxP = max(maxP, prices[i + 1]);
sum2 = max(sum2, maxP - prices[i]);
if(sum2 &gt; 0) {
//这里我们直接将其加入profits里面，
//不需要额外保存
profits[i] = profits[i] + sum2;
sum = max(sum, profits[i]);
}
} 
return sum &gt; 0 ? sum : 0;
}
};
</code></pre>
    </div>
    <h1 id="50-棋盘路径">50 棋盘路径</h1>
  </li>
  <li>组合数爆int内存
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int uniquePaths(int m, int n) {
vector&lt;vector&lt;int&gt;&gt; dp;
dp.resize(n);
for(int i = 0;i&lt;n;i++)
dp[i].resize(m);
dp[0][0] = 1;
for(int i = 0;i &lt; n;i++)
{
for(int j = 0;j &lt; m;j++)
{
if(i &gt; 0&amp;&amp;j&gt;0)
{
dp[i][j] = dp[i][j-1]+dp[i-1][j];
}
else if(i&gt;0)
{
dp[i][j] = dp[i-1][j];
}
else if(j&gt;0)
dp[i][j] = dp[i][j-1];
}
}
return dp[n-1][m-1];
}
};
</code></pre>
    </div>
    <h1 id="51-路径上有障碍">51 路径上有障碍</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
vector&lt;vector&lt;int&gt;&gt; dp = obstacleGrid;
dp[0][0] = 1;
for(int i = 0;i &lt; dp.size();i++)
{
for(int j = 0;j &lt; dp[i].size();j++)
{
if(obstacleGrid[i][j])
{
dp[i][j] = 0;
continue;
}
if(i &gt; 0&amp;&amp;j&gt;0)
{
dp[i][j] = dp[i][j-1]+dp[i-1][j];
}
else if(i&gt;0)
{
dp[i][j] = dp[i-1][j];
}
else if(j&gt;0)
dp[i][j] = dp[i][j-1];
}
}
return dp.back().back();
}
};
</code></pre>
    </div>
    <h1 id="52-最小路径和">52 最小路径和</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
vector&lt;vector&lt;int&gt;&gt; dp = grid;
for(int i = 0;i&lt;dp.size();i++)
{
for(int j = 0;j &lt; dp[i].size();j++)
{
if(i &gt; 0&amp;&amp;j&gt;0)
{
dp[i][j] += min(dp[i][j-1],dp[i-1][j]);
}
else if(i&gt;0)
{
dp[i][j] += dp[i-1][j];
}
else if(j&gt;0)
dp[i][j] += dp[i][j-1];
}
}
return dp.back().back();
}
};
</code></pre>
    </div>
    <h1 id="53-最大子段和">53 最大子段和</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int maxSubArray(vector&lt;int&gt;&amp; nums) {
vector&lt;int&gt; dp = nums;
int max = nums[0];
for(int i = 1;i &lt; dp.size();i++)
{
if(dp[i-1] &gt; 0) 
dp[i] += dp[i-1];
if(dp[i] &gt; max)
max = dp[i];
}
return max;
}
};
</code></pre>
    </div>
    <h1 id="54-最大子段积">54 最大子段积</h1>
  </li>
  <li>维护一个最大最小值dp
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int maxProduct(vector&lt;int&gt;&amp; nums) {
vector&lt;int&gt; max_dp = nums;
vector&lt;int&gt; min_dp = nums;
int max_num = nums[0];
for(int i = 1;i&lt;nums.size();i++)
{
int max_cur = nums[i] * max_dp[i-1];
int min_cur = nums[i] * min_dp[i-1];
max_dp[i] = max(nums[i],max_cur);
max_dp[i] = max(max_dp[i],min_cur);
min_dp[i] = min(nums[i],max_cur);
min_dp[i] = min(min_dp[i],min_cur);
if(max_dp[i] &gt; max_num)
max_num = max_dp[i];
}
return max_num;
}
};
</code></pre>
    </div>
    <h1 id="55-走台阶-斐波那契额数列">55 走台阶 斐波那契额数列</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int climbStairs(int n) {
vector&lt;int&gt; dp;
dp.resize(n + 2);
dp[0] = 1;
dp[1] = 2;
for(int i = 2;i &lt; n;i++)
{
dp[i] = dp[i-1] + dp[i-2];
}
return dp[n-1];
}
};
</code></pre>
    </div>
    <h1 id="56-三角形求最短路径">56 三角形求最短路径</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
vector&lt;int&gt; dp;
dp.resize(triangle.size());
int min_num = triangle[0][0];
dp[0] = min_num;
for(int i = 1;i &lt; triangle.size();i++)
{
min_num = numeric_limits&lt;int&gt;::max();
for(int j = i;j&gt;=0;j--)
{
if(j == i)
dp[j] = triangle[i][j] + dp[j-1];
else if(j == 0)
dp[j] = triangle[i][j] + dp[j];
else
dp[j] = triangle[i][j] + min(dp[j-1],dp[j]);
if(dp[j] &lt; min_num)
min_num = dp[j];
}
}
return min_num;
}
};
</code></pre>
    </div>
    <h1 id="57-输入n判断1-n有多少种二叉搜索树的形态">57 输入n，判断1-n有多少种二叉搜索树的形态</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int numTrees(int n) {
vector&lt;int&gt; dp(n+1,0);
dp.resize(n);
dp[0] = 1;
dp[1] = 1;
for(int i = 2;i &lt;= n;i++)
{
for(int j = 0;j &lt; i;j++)
{
dp[i] += dp[j] * dp[i-j-1];
}
}
return dp[n];
}
};
</code></pre>
    </div>
    <h1 id="58-输出这么多种二叉树的形态">58 输出这么多种二叉树的形态</h1>
  </li>
  <li>一层一层返回结点构建树即可 这个返回结点的方法很巧妙，用的vector
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
vector&lt;TreeNode*&gt; generateTrees(int n) {
if(n &lt; 1)
return vector&lt;TreeNode*&gt;(NULL);
return createTree(1,n);
}
vector&lt;TreeNode*&gt; createTree(int start,int end)
{
vector&lt;TreeNode *&gt; cur_tree;
if(start &gt; end)
{
cur_tree.push_back(NULL);
return cur_tree;
}
for(int i = start;i &lt;= end;i++)
{
vector&lt;TreeNode *&gt; l = createTree(start,i -1);
vector&lt;TreeNode *&gt; r = createTree(i+1,end);
for(int j = 0;j &lt; l.size();j++)
{
for(int k = 0;k &lt; r.size();k++)
{
TreeNode* root = new TreeNode(i);
root-&gt;left = l[j];
root-&gt;right = r[k];
cur_tree.push_back(root);
}
}
}
return cur_tree;
}
};
</code></pre>
    </div>
    <h1 id="59-求一个数由几个完全平方数组成">59 求一个数由几个完全平方数组成</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int numSquares(int n) {
vector&lt;int&gt; dp(n + 1,numeric_limits&lt;int&gt;::max());
if(n &lt; 1)
return 0;
dp[0] = 0;
for(int i = 0;i&lt;n;i++)
{
for(int j = 1;i + j * j &lt;= n;j++)
{
dp[i + j * j] = min(dp[i + j*j],dp[i] + 1); 
}
}
return dp[n];
}
};
</code></pre>
    </div>
    <h1 id="60-gas-station">60 gas station</h1>
  </li>
  <li>一个环形加油站，判断能否开一圈循环。</li>
  <li>思路是发现无法开到下一站了，就设置下一站为起点，因为是循环的，所以没问题。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
if(gas.empty())
return 0;
int sum = 0;
int start = 0;
int total = 0;
for(int i = 0;i &lt; gas.size();i++)
{
sum += gas[i] - cost[i];
if(sum &lt; 0)
{
start = i+1;
sum = 0;
}
total += gas[i] - cost[i];
}
return total&gt;=0?start:-1;
}
};
</code></pre>
    </div>
    <h1 id="61-candy">61 candy</h1>
  </li>
  <li>边界条件判断很重要
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
int candy(vector&lt;int&gt;&amp; ratings) {
vector&lt;int&gt; child_candy(ratings.size(),1);
for(int i = 1;i &lt; ratings.size();i++)
{
if(ratings[i] &gt; ratings[i-1])
child_candy[i] = child_candy[i-1] + 1;
}
int sum = child_candy.back();
for(int i = ratings.size() - 2;i &gt;= 0;i--)
{
if(ratings[i] &gt; ratings[i+1] &amp;&amp; child_candy[i] &lt;= child_candy[i + 1])
child_candy[i] = child_candy[i+1] + 1;
sum += child_candy[i];
}
return sum;
}
};
</code></pre>
    </div>
    <h1 id="62-判断字符串能否被分割成子串子串在字典中存在">62 判断字符串能否被分割成子串，子串在字典中存在。</h1>
  </li>
  <li>dp思想
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {
vector&lt;bool&gt; dp(s.length()+1,0);
dp[0] = 1;
for(int i = 1;i &lt;= s.length();i++)
{
for(int j = 0;j &lt; i;j++)
{
if(dp[j] &amp;&amp; find(wordDict.begin(),wordDict.end(),s.substr(j,i-j))!=wordDict.end())
{
dp[i] = true;
break;
}
}
}
return dp[s.length()];
}
};
</code></pre>
    </div>
    <h1 id="63-判断链表是否有环">63 判断链表是否有环</h1>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
bool hasCycle(ListNode *head) {
ListNode *fast = head;
ListNode *slow = head;
while(fast)
{
fast = fast-&gt;next;
if(fast)
fast = fast-&gt;next;
else
break;
slow = slow-&gt;next;
if(fast == slow)
return true;
}
return false;
}
};
</code></pre>
    </div>
    <h1 id="64-判断环在哪">64 判断环在哪</h1>
  </li>
  <li>两个重合后一个从头开始走，一个从当前位置开始走，会在环处重合。
    <div class="highlighter-rouge"><pre class="highlight"><code>class Solution {
public:
ListNode *detectCycle(ListNode *head) {
ListNode *fast = head;
ListNode *slow = head;
while(fast)
{
fast = fast-&gt;next;
if(fast)
fast = fast-&gt;next;
else
break;
slow = slow-&gt;next;
if(fast == slow)
{
slow = head;
while(fast &amp;&amp; slow){
if(fast == slow)
return slow;
fast = fast-&gt;next;
slow = slow-&gt;next;
}
}
}
return NULL;
}
};
</code></pre>
    </div>
  </li>
</ul>

            </article>

            <section class="share">

    <h3>Share</h3>

    <a aria-label="Share on Twitter" href="https://twitter.com/intent/tweet?text=&quot;&quot;%20http://localhost:4000/coding/%20via%20&#64;RiziaGXY&hashtags=coding for fun,"
    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" title="Share on Twitter">
        <svg class="icon icon-twitter"><use xlink:href="#icon-twitter"></use></svg>
    </a>

    <a aria-label="Share on Facebook"href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/coding/"
    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;" title="Share on Facebook">
        <svg class="icon icon-facebook"><use xlink:href="#icon-facebook"></use></svg>
    </a>

    <a aria-label="Share on Google Plus" href="https://plus.google.com/share?url=http://localhost:4000/coding/"
    onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;" title="Share on Google+">
        <svg class="icon icon-google-plus"><use xlink:href="#icon-google-plus"></use></svg>
    </a>

</section>

            <section class="comments">

    <h3>Comments</h3>
    <div id="disqus_thread"></div>

</section>

<script type="text/javascript">

    var disqus_loaded = false;

    function load_disqus(){
        disqus_loaded = true;
        var disqus_shortname = 'NONE';
        var disqus_title = '';
        var disqus_url = '/coding/';
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        var ldr = document.getElementById('disqus_loader');
    };

    window.onscroll = function(e) {
        if ((window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 800)) {
            //hit bottom of page
            if (disqus_loaded==false)
                load_disqus()
        }
    };
</script>

            <footer>

	<p>Made by <span id="heart">GaoXinyu</span></p>

</footer>

            <script src="/assets/js/main.js"></script>
        </section>
    </body>
</html>
